MVP Questions
In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?
In console.rb we instantiate instances of the Property class so that we can test our database code.

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
In the Property class.

Q3. In console.rb, which lines modify the database?
None of them.

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?


Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?

Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
If an element of a database is returned without an id, we want it to be returned nil so that
it's clear to us it doesn't have one.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
For methods that make sense to apply universally across our database (like delete_all),
class methods are more appropriate to use as, in order to use an instance method, we must first
create an instance -- this would be redundant (particularly in the case of delete_all).

Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?
A hash within an array.  We access the id by assigning the array returned by exec_prepared to a variable, then assigning
the grabbing of that data (array[0]['id']) to our instance variable @id.

Q9. Why do we use prepared statements when performing database operations?
To protect our database from SQL injection.

Extension Questions
Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?
Whatever data element we are using methods to search for within our database is what we pass into
the method as an argument.

Q11. What are their return values?
Indexes of an array (specifically a hash).
